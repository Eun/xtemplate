//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"sort"
	"strings"
)

func main() {
	// Parse the current package
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse package: %v", err)
	}

	var funcSet = make(map[string]map[string]struct{})

	// Iterate through all packages
	for _, pkg := range pkgs {
		// Skip the main package (this generator itself)
		if pkg.Name == "main" {
			continue
		}

		// Iterate through all files in the package
		for _, file := range pkg.Files {
			set := extractContextMethods(file)
			for context, methods := range set {
				if _, ok := funcSet[context]; !ok {
					funcSet[context] = make(map[string]struct{})
				}
				for method := range methods {
					funcSet[context][method] = struct{}{}
				}
			}
		}
	}

	// Generate the output file
	if err := generateFuncs(funcSet); err != nil {
		log.Fatalf("Failed to generate funcs.gen.go: %v", err)
	}

	fmt.Println("Generated funcs/funcs.gen.go")
}

func extractContextMethods(file *ast.File) map[string]map[string]struct{} {
	result := make(map[string]map[string]struct{})

	ast.Inspect(file, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.TypeSpec:
			// Check if this type has rootContext as base type
			if ident, ok := node.Type.(*ast.Ident); ok && ident.Name == "rootContext" {
				// Convert type name to lowercase namespace (e.g., "Strings" -> "strings")
				result[node.Name.Name] = make(map[string]struct{})
			}
		}
		return true
	})

	// Then, find all methods for these types
	ast.Inspect(file, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.FuncDecl:
			// Check if this is a method (has a receiver)
			if node.Recv != nil && len(node.Recv.List) > 0 {
				recv := node.Recv.List[0]

				// Get receiver type name
				var typeName string
				switch recvType := recv.Type.(type) {
				case *ast.Ident:
					typeName = recvType.Name
				case *ast.StarExpr:
					if ident, ok := recvType.X.(*ast.Ident); ok {
						typeName = ident.Name
					}
				}

				if !node.Name.IsExported() {
					return true
				}
				m, ok := result[typeName]
				if ok {
					m[node.Name.Name] = struct{}{}
				}
			}
		}
		return true
	})

	return result
}

func generateFuncs(set map[string]map[string]struct{}) error {
	// Create the output file
	outFile, err := os.Create("funcs/funcs.gen.go")
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Write package declaration
	fmt.Fprintln(outFile, "// Code generated by generate_funcs.go; DO NOT EDIT.")
	fmt.Fprintln(outFile)
	fmt.Fprintln(outFile, "package funcs")
	fmt.Fprintln(outFile)

	type Method struct {
		Context    string
		Method     string
		MethodName string
	}
	type Collection struct {
		Context string
		Methods []Method
	}

	var collections []Collection
	var methods []Method
	for context, methodSet := range set {
		col := Collection{
			Context: context,
			Methods: make([]Method, 0, len(methodSet)),
		}
		for methodName := range methodSet {
			col.Methods = append(col.Methods, Method{
				Context:    context,
				Method:     methodName,
				MethodName: methodName,
			})
		}

		collections = append(collections, col)
		methods = append(methods, col.Methods...)
	}

	// Sort methods for consistent output
	sort.Slice(methods, func(i, j int) bool {
		return methods[i].Context+methods[i].Method < methods[j].Context+methods[j].Method
	})

	fmt.Fprintln(outFile, "// Methods")
	fmt.Fprintln(outFile, "var (")
	for _, method := range methods {
		fmt.Fprintf(
			outFile,
			"\t%s = Func { %q, %q }\n",
			method.Context+method.Method,
			strings.ToLower(method.Context),
			method.MethodName,
		)
	}
	fmt.Fprintln(outFile, ")")

	sort.Slice(collections, func(i, j int) bool {
		return collections[i].Context < collections[j].Context
	})

	fmt.Fprintln(outFile, "// Collections")
	fmt.Fprintln(outFile, "var (")
	for _, collection := range collections {
		fmt.Fprintf(outFile, "\t%s = Funcs {\n", collection.Context)
		for _, method := range collection.Methods {
			fmt.Fprintf(outFile, "\t\t%s,\n", method.Context+method.Method)
		}
		fmt.Fprintln(outFile, "\t}\n")
	}

	fmt.Fprint(outFile, "\tAll = Funcs {\n")
	for _, method := range methods {
		fmt.Fprintf(outFile, "\t\t%s,\n", method.Context+method.Method)
	}
	fmt.Fprintln(outFile, "\t}")
	fmt.Fprintln(outFile, ")")

	// Write struct type definition
	fmt.Fprintln(outFile, "var NamespacesAndTheirFunctions = map[string]map[string]struct{}{")

	contexts := make([]string, 0, len(set))
	for context := range set {
		contexts = append(contexts, context)
	}
	sort.Strings(contexts)

	for _, context := range contexts {
		fmt.Fprintf(outFile, "\t\"%s\": {\n", strings.ToLower(context))

		methodsInContext := make([]string, 0, len(set[context]))
		for method := range set[context] {
			methodsInContext = append(methodsInContext, method)
		}
		sort.Strings(methodsInContext)

		for _, method := range methodsInContext {
			fmt.Fprintf(outFile, "\t\t\"%s\": {},\n", method)
		}

		fmt.Fprint(outFile, "\t},\n")
	}

	fmt.Fprintln(outFile, "}")

	return nil
}
